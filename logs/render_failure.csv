page,error
_posts/national/belgium/belgium.Rmd,"list(message = ""Problem with `summarise()` column `geometry`.\nℹ `geometry = st_union(geometry)`.\n✖ there is no package called 's2'\nℹ The error occurred in group 1: region = \""Capital Region\""."", trace = list(calls = list(purrr::map(posts[purrr::map_lgl(failed_to_render[[2]], ~!is.null(.))], render_by_path), global::.f(.x[[i]], ...), purrr:::safe_render(file.path(post), quiet = FALSE), purrr:::capture_error(.f(...), otherwise, quiet), base::tryCatch(list(result = code, error = NULL), error = function(e) {
    if (!quiet) 
        message(""Error: "", e$message)
    list(result = otherwise, error = e)
}, interrupt = function(e) {
    stop(""Terminated by user"", call. = FALSE)
}), base:::tryCatchList(expr, classes, parentenv, handlers), base:::tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], parentenv, handlers[[nh]]), base:::doTryCatch(return(expr), name, parentenv, handler), base:::tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), base:::tryCatchOne(expr, names, parentenv, handlers[[1]]), base:::doTryCatch(return(expr), name, parentenv, handler), rmarkdown:::.f(...), knitr::knit(knit_input, knit_output, envir = envir, quiet = quiet), 
    knitr:::process_file(text, output), base::withCallingHandlers(if (tangle) process_tangle(group) else process_group(group), error = function(e) {
        setwd(wd)
        cat(res, sep = ""\n"", file = output %n% """")
        message(""Quitting from lines "", paste(current_lines(i), collapse = ""-""), "" ("", knit_concord$get(""infile""), "") "")
    }), knitr:::process_group(group), knitr:::process_group.block(group), knitr:::call_block(x), knitr:::block_exec(params), knitr:::eng_r(options), knitr:::in_dir(input_dir(), evaluate(code, envir = env, new_device = FALSE, keep_warning = !isFALSE(options$warning), keep_message = !isFALSE(options$message), stop_on_error = if (is.numeric(options$error)) options$error else {
        if (options$error && options$include) 
            0
        else 2
    }, output_handler = knit_handlers(options$render, options))), knitr:::evaluate(code, envir = env, new_device = FALSE, keep_warning = !isFALSE(options$warning), keep_message = !isFALSE(options$message), stop_on_error = if (is.numeric(options$error)) options$error else {
        if (options$error && options$include) 
            0
        else 2
    }, output_handler = knit_handlers(options$render, options)), evaluate::evaluate(...), evaluate:::evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, last = i == length(out), use_try = stop_on_error != 2, keep_warning = keep_warning, keep_message = keep_message, output_handler = output_handler, include_timing = include_timing), evaluate:::timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, error = eHandler, message = mHandler))), 
    base:::handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)), base::withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, error = eHandler, message = mHandler), base::withVisible(eval(expr, envir, enclos)), base::eval(expr, envir, enclos), base::eval(expr, envir, enclos), rnaturalearth::ne_states(""Belgium"", returnclass = ""sf"") %>% group_by(region) %>% summarise(geometry = st_union(geometry), 
        .groups = ""drop"") %>% mutate(region = recode_factor(region, `Capital Region` = ""Brussels"", Flemish = ""Flanders"", Walloon = ""Wallonia"")) %>% rename(Region = region), dplyr::rename(., Region = region), dplyr::mutate(., region = recode_factor(region, `Capital Region` = ""Brussels"", Flemish = ""Flanders"", Walloon = ""Wallonia"")), dplyr::summarise(., geometry = st_union(geometry), .groups = ""drop""), sf:::summarise.sf(., geometry = st_union(geometry), .groups = ""drop""), base::NextMethod(), dplyr:::summarise.grouped_df(., 
        geometry = st_union(geometry), .groups = ""drop""), dplyr:::summarise_cols(.data, ..., caller_env = caller_env()), base::withCallingHandlers({
        for (i in seq_along(dots)) {
            mask$across_cache_reset()
            context_poke(""column"", old_current_column)
            quosures <- expand_across(dots[[i]])
            quosures_results <- vector(mode = ""list"", length = length(quosures))
            for (k in seq_along(quosures)) {
                quo <- quosures[[k]]
                quo_data <- attr(quo, ""dplyr:::data"")
                if (!is.null(quo_data$column)) {
                  context_poke(""column"", quo_data$column)
                }
                chunks_k <- mask$eval_all_summarise(quo)
                if (is.null(chunks_k)) {
                  next
                }
                types_k <- withCallingHandlers(vec_ptype_common(!!!chunks_k), vctrs_error_incompatible_type = function(cnd) {
                  abort(class = ""dplyr:::error_summarise_incompatible_combine"", parent = cnd)
                })
                chunks_k <- vec_cast_common(!!!chunks_k, .to = types_k)
                quosures_results[[k]] <- list(chunks = chunks_k, types = types_k)
            }
            for (k in seq_along(quosures)) {
                quo <- quosures[[k]]
                quo_data <- attr(quo, ""dplyr:::data"")
                quo_result <- quosures_results[[k]]
                if (is.null(quo_result)) {
                  next
                }
                types_k <- quo_result$types
                chunks_k <- quo_result$chunks
                if (!quo_data$is_named && is.data.frame(types_k)) {
                  chunks_extracted <- .Call(dplyr_extract_chunks, chunks_k, types_k)
                  walk2(chunks_extracted, names(types_k), function(chunks_k_j, nm) {
                    mask$add_one(nm, chunks_k_j)
                  })
                  chunks <- append(chunks, chunks_extracted)
                  types <- append(types, as.list(types_k))
                  out_names <- c(out_names, names(types_k))
                }
                else {
                  name <- quo_data$name_auto
                  mask$add_one(name, chunks_k)
                  chunks <- append(chunks, list(chunks_k))
                  types <- append(types, list(types_k))
                  out_names <- c(out_names, name)
                }
            }
        }
        recycle_info <- .Call(dplyr_summarise_recycle_chunks, chunks, mask$get_rows(), types)
        chunks <- recycle_info$chunks
        sizes <- recycle_info$sizes
        for (i in seq_along(chunks)) {
            result <- vec_c(!!!chunks[[i]], .ptype = types[[i]])
            cols[[out_names[i]]] <- result
        }
    }, error = function(e) {
        local_call_step(dots = dots, .index = i, .fn = ""summarise"", .dot_data = inherits(e, ""rlang_error_data_pronoun_not_found""))
        call_step <- peek_call_step()
        error_name <- call_step$error_name
        show_group_details <- TRUE
        if (inherits(e, ""dplyr:::error_summarise_incompatible_combine"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups"", .envir = peek_call_step()), i = cnd_bullet_combine_details(e$parent$x, e$parent$x_arg), i = cnd_bullet_combine_details(e$parent$y, e$parent$y_arg))
        }
        else if (inherits(e, ""dplyr:::summarise_unsupported_type"")) {
            bullets <- c(x = glue(""`{error_name}` must be a vector, not {friendly_type_of(result)}."", result = e$result), i = cnd_bullet_rowwise_unlist())
        }
        else if (inherits(e, ""dplyr:::summarise_incompatible_size"")) {
            peek_mask()$set_current_group(e$group)
            bullets <- c(x = glue(""`{error_name}` must be size {or_1(expected_size)}, not {size}."", expected_size = e$expected_size, size = e$size), i = glue(""An earlier column had size {expected_size}."", expected_size = e$expected_size))
        }
        else if (inherits(e, ""dplyr:::summarise_mixed_null"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups.""), i = ""Cannot combine NULL and non NULL results."")
        }
        else {
            bullets <- c(x = conditionMessage(e))
        }
        bullets <- c(cnd_bullet_header(), i = cnd_bullet_column_info(), bullets, i = if (show_group_details) cnd_bullet_cur_group_label())
        abort(bullets, class = ""dplyr_error"")
    }), mask$eval_all_summarise(quo), sf::st_union(geometry), sf:::st_union.sfc(geometry), sf::st_as_sfc(s2::s2_union_agg(x, ...), crs = st_crs(x)), s2::s2_union_agg, base::getExportedValue(pkg, name), base::asNamespace(ns), base::getNamespace(ns), base::loadNamespace(name), base::withRestarts(stop(cond), retry_loadNamespace = function() NULL), base:::withOneRestart(expr, restarts[[1]]), base:::doWithOneRestart(return(expr), restart), base::stop(cond), (function (e) 
    {
        local_call_step(dots = dots, .index = i, .fn = ""summarise"", .dot_data = inherits(e, ""rlang_error_data_pronoun_not_found""))
        call_step <- peek_call_step()
        error_name <- call_step$error_name
        show_group_details <- TRUE
        if (inherits(e, ""dplyr:::error_summarise_incompatible_combine"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups"", .envir = peek_call_step()), i = cnd_bullet_combine_details(e$parent$x, e$parent$x_arg), i = cnd_bullet_combine_details(e$parent$y, e$parent$y_arg))
        }
        else if (inherits(e, ""dplyr:::summarise_unsupported_type"")) {
            bullets <- c(x = glue(""`{error_name}` must be a vector, not {friendly_type_of(result)}."", result = e$result), i = cnd_bullet_rowwise_unlist())
        }
        else if (inherits(e, ""dplyr:::summarise_incompatible_size"")) {
            peek_mask()$set_current_group(e$group)
            bullets <- c(x = glue(""`{error_name}` must be size {or_1(expected_size)}, not {size}."", expected_size = e$expected_size, size = e$size), i = glue(""An earlier column had size {expected_size}."", expected_size = e$expected_size))
        }
        else if (inherits(e, ""dplyr:::summarise_mixed_null"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups.""), i = ""Cannot combine NULL and non NULL results."")
        }
        else {
            bullets <- c(x = conditionMessage(e))
        }
        bullets <- c(cnd_bullet_header(), i = cnd_bullet_column_info(), bullets, i = if (show_group_details) cnd_bullet_cur_group_label())
        abort(bullets, class = ""dplyr_error"")
    })(list(message = ""there is no package called 's2'"", call = loadNamespace(name), package = ""s2"", lib.loc = NULL))), parents = c(0, 1, 2, 3, 4, 5, 6, 7, 6, 9, 10, 3, 12, 13, 14, 14, 14, 17, 18, 19, 20, 20, 22, 23, 24, 24, 24, 24, 24, 29, 3, 0, 0, 0, 0, 0, 0, 37, 38, 38, 0, 0, 42, 42, 44, 45, 46, 47, 48, 49, 50, 48, 0), indices = 1:53), parent = NULL)"
_posts/national/italy/italy.Rmd,"list(message = ""Problem with `summarise()` column `geometry`.\nℹ `geometry = st_union(geometry)`.\n✖ there is no package called 's2'\nℹ The error occurred in group 1: provnum_ne = 1."", trace = list(calls = list(purrr::map(posts[purrr::map_lgl(failed_to_render[[2]], ~!is.null(.))], render_by_path), global::.f(.x[[i]], ...), purrr:::safe_render(file.path(post), quiet = FALSE), purrr:::capture_error(.f(...), otherwise, quiet), base::tryCatch(list(result = code, error = NULL), error = function(e) {
    if (!quiet) 
        message(""Error: "", e$message)
    list(result = otherwise, error = e)
}, interrupt = function(e) {
    stop(""Terminated by user"", call. = FALSE)
}), base:::tryCatchList(expr, classes, parentenv, handlers), base:::tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], parentenv, handlers[[nh]]), base:::doTryCatch(return(expr), name, parentenv, handler), base:::tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), base:::tryCatchOne(expr, names, parentenv, handlers[[1]]), base:::doTryCatch(return(expr), name, parentenv, handler), rmarkdown:::.f(...), knitr::knit(knit_input, knit_output, envir = envir, quiet = quiet), 
    knitr:::process_file(text, output), base::withCallingHandlers(if (tangle) process_tangle(group) else process_group(group), error = function(e) {
        setwd(wd)
        cat(res, sep = ""\n"", file = output %n% """")
        message(""Quitting from lines "", paste(current_lines(i), collapse = ""-""), "" ("", knit_concord$get(""infile""), "") "")
    }), knitr:::process_group(group), knitr:::process_group.block(group), knitr:::call_block(x), knitr:::block_exec(params), knitr:::eng_r(options), knitr:::in_dir(input_dir(), evaluate(code, envir = env, new_device = FALSE, keep_warning = !isFALSE(options$warning), keep_message = !isFALSE(options$message), stop_on_error = if (is.numeric(options$error)) options$error else {
        if (options$error && options$include) 
            0
        else 2
    }, output_handler = knit_handlers(options$render, options))), knitr:::evaluate(code, envir = env, new_device = FALSE, keep_warning = !isFALSE(options$warning), keep_message = !isFALSE(options$message), stop_on_error = if (is.numeric(options$error)) options$error else {
        if (options$error && options$include) 
            0
        else 2
    }, output_handler = knit_handlers(options$render, options)), evaluate::evaluate(...), evaluate:::evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, last = i == length(out), use_try = stop_on_error != 2, keep_warning = keep_warning, keep_message = keep_message, output_handler = output_handler, include_timing = include_timing), evaluate:::timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, error = eHandler, message = mHandler))), 
    base:::handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)), base::withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, error = eHandler, message = mHandler), base::withVisible(eval(expr, envir, enclos)), base::eval(expr, envir, enclos), base::eval(expr, envir, enclos), rnaturalearth::ne_states(""Italy"", returnclass = ""sf"") %>% group_by(provnum_ne) %>% summarise(geometry = st_union(geometry), 
        .groups = ""drop""), dplyr::summarise(., geometry = st_union(geometry), .groups = ""drop""), sf:::summarise.sf(., geometry = st_union(geometry), .groups = ""drop""), base::NextMethod(), dplyr:::summarise.grouped_df(., geometry = st_union(geometry), .groups = ""drop""), dplyr:::summarise_cols(.data, ..., caller_env = caller_env()), base::withCallingHandlers({
        for (i in seq_along(dots)) {
            mask$across_cache_reset()
            context_poke(""column"", old_current_column)
            quosures <- expand_across(dots[[i]])
            quosures_results <- vector(mode = ""list"", length = length(quosures))
            for (k in seq_along(quosures)) {
                quo <- quosures[[k]]
                quo_data <- attr(quo, ""dplyr:::data"")
                if (!is.null(quo_data$column)) {
                  context_poke(""column"", quo_data$column)
                }
                chunks_k <- mask$eval_all_summarise(quo)
                if (is.null(chunks_k)) {
                  next
                }
                types_k <- withCallingHandlers(vec_ptype_common(!!!chunks_k), vctrs_error_incompatible_type = function(cnd) {
                  abort(class = ""dplyr:::error_summarise_incompatible_combine"", parent = cnd)
                })
                chunks_k <- vec_cast_common(!!!chunks_k, .to = types_k)
                quosures_results[[k]] <- list(chunks = chunks_k, types = types_k)
            }
            for (k in seq_along(quosures)) {
                quo <- quosures[[k]]
                quo_data <- attr(quo, ""dplyr:::data"")
                quo_result <- quosures_results[[k]]
                if (is.null(quo_result)) {
                  next
                }
                types_k <- quo_result$types
                chunks_k <- quo_result$chunks
                if (!quo_data$is_named && is.data.frame(types_k)) {
                  chunks_extracted <- .Call(dplyr_extract_chunks, chunks_k, types_k)
                  walk2(chunks_extracted, names(types_k), function(chunks_k_j, nm) {
                    mask$add_one(nm, chunks_k_j)
                  })
                  chunks <- append(chunks, chunks_extracted)
                  types <- append(types, as.list(types_k))
                  out_names <- c(out_names, names(types_k))
                }
                else {
                  name <- quo_data$name_auto
                  mask$add_one(name, chunks_k)
                  chunks <- append(chunks, list(chunks_k))
                  types <- append(types, list(types_k))
                  out_names <- c(out_names, name)
                }
            }
        }
        recycle_info <- .Call(dplyr_summarise_recycle_chunks, chunks, mask$get_rows(), types)
        chunks <- recycle_info$chunks
        sizes <- recycle_info$sizes
        for (i in seq_along(chunks)) {
            result <- vec_c(!!!chunks[[i]], .ptype = types[[i]])
            cols[[out_names[i]]] <- result
        }
    }, error = function(e) {
        local_call_step(dots = dots, .index = i, .fn = ""summarise"", .dot_data = inherits(e, ""rlang_error_data_pronoun_not_found""))
        call_step <- peek_call_step()
        error_name <- call_step$error_name
        show_group_details <- TRUE
        if (inherits(e, ""dplyr:::error_summarise_incompatible_combine"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups"", .envir = peek_call_step()), i = cnd_bullet_combine_details(e$parent$x, e$parent$x_arg), i = cnd_bullet_combine_details(e$parent$y, e$parent$y_arg))
        }
        else if (inherits(e, ""dplyr:::summarise_unsupported_type"")) {
            bullets <- c(x = glue(""`{error_name}` must be a vector, not {friendly_type_of(result)}."", result = e$result), i = cnd_bullet_rowwise_unlist())
        }
        else if (inherits(e, ""dplyr:::summarise_incompatible_size"")) {
            peek_mask()$set_current_group(e$group)
            bullets <- c(x = glue(""`{error_name}` must be size {or_1(expected_size)}, not {size}."", expected_size = e$expected_size, size = e$size), i = glue(""An earlier column had size {expected_size}."", expected_size = e$expected_size))
        }
        else if (inherits(e, ""dplyr:::summarise_mixed_null"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups.""), i = ""Cannot combine NULL and non NULL results."")
        }
        else {
            bullets <- c(x = conditionMessage(e))
        }
        bullets <- c(cnd_bullet_header(), i = cnd_bullet_column_info(), bullets, i = if (show_group_details) cnd_bullet_cur_group_label())
        abort(bullets, class = ""dplyr_error"")
    }), mask$eval_all_summarise(quo), sf::st_union(geometry), sf:::st_union.sfc(geometry), sf::st_as_sfc(s2::s2_union_agg(x, ...), crs = st_crs(x)), s2::s2_union_agg, base::getExportedValue(pkg, name), base::asNamespace(ns), base::getNamespace(ns), base::loadNamespace(name), base::withRestarts(stop(cond), retry_loadNamespace = function() NULL), base:::withOneRestart(expr, restarts[[1]]), base:::doWithOneRestart(return(expr), restart), base::stop(cond), (function (e) 
    {
        local_call_step(dots = dots, .index = i, .fn = ""summarise"", .dot_data = inherits(e, ""rlang_error_data_pronoun_not_found""))
        call_step <- peek_call_step()
        error_name <- call_step$error_name
        show_group_details <- TRUE
        if (inherits(e, ""dplyr:::error_summarise_incompatible_combine"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups"", .envir = peek_call_step()), i = cnd_bullet_combine_details(e$parent$x, e$parent$x_arg), i = cnd_bullet_combine_details(e$parent$y, e$parent$y_arg))
        }
        else if (inherits(e, ""dplyr:::summarise_unsupported_type"")) {
            bullets <- c(x = glue(""`{error_name}` must be a vector, not {friendly_type_of(result)}."", result = e$result), i = cnd_bullet_rowwise_unlist())
        }
        else if (inherits(e, ""dplyr:::summarise_incompatible_size"")) {
            peek_mask()$set_current_group(e$group)
            bullets <- c(x = glue(""`{error_name}` must be size {or_1(expected_size)}, not {size}."", expected_size = e$expected_size, size = e$size), i = glue(""An earlier column had size {expected_size}."", expected_size = e$expected_size))
        }
        else if (inherits(e, ""dplyr:::summarise_mixed_null"")) {
            show_group_details <- FALSE
            bullets <- c(x = glue(""`{error_name}` must return compatible vectors across groups.""), i = ""Cannot combine NULL and non NULL results."")
        }
        else {
            bullets <- c(x = conditionMessage(e))
        }
        bullets <- c(cnd_bullet_header(), i = cnd_bullet_column_info(), bullets, i = if (show_group_details) cnd_bullet_cur_group_label())
        abort(bullets, class = ""dplyr_error"")
    })(list(message = ""there is no package called 's2'"", call = loadNamespace(name), package = ""s2"", lib.loc = NULL))), parents = c(0, 1, 2, 3, 4, 5, 6, 7, 6, 9, 10, 3, 12, 13, 14, 14, 14, 17, 18, 19, 20, 20, 22, 23, 24, 24, 24, 24, 24, 29, 3, 0, 0, 0, 0, 35, 36, 36, 0, 0, 40, 40, 42, 43, 44, 45, 46, 47, 48, 46, 0), indices = 1:51), parent = NULL)"
_posts/national/united-kingdom/united-kingdom.Rmd,"list(message = ""object 'type' not found"", call = `[.data.frame`(x, i))"
_posts/subnational/russia/moscow/moscow.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/moscow/moscow.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/moscow/moscow.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/nizhny-novgorod-oblast/nizhny-novgorod-oblast.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/nizhny-novgorod-oblast/nizhny-novgorod-oblast.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/nizhny-novgorod-oblast/nizhny-novgorod-oblast.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/omsk-oblast/omsk-oblast.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/omsk-oblast/omsk-oblast.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/omsk-oblast/omsk-oblast.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/saint-petersburg/saint-petersburg.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/saint-petersburg/saint-petersburg.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/russia/saint-petersburg/saint-petersburg.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/united-kingdom-local/cornwall/cornwall.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/united-kingdom-local/cornwall/cornwall.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/united-kingdom-local/cornwall/cornwall.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/united-kingdom-local/hackney/hackney.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/united-kingdom-local/hackney/hackney.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
_posts/subnational/united-kingdom-local/hackney/hackney.Rmd,"list(message = ""cannot open the connection"", call = gzfile(file, ""rb""))"
